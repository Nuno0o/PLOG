\documentclass[a4paper]{article}

%use the english line for english reports
%usepackage[english]{babel}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{verbatim}


\begin{document}

\setlength{\textwidth}{16cm}
\setlength{\textheight}{22cm}

\title{\Huge\textbf{Título do Trabalho}\linebreak\linebreak\linebreak
\Large\textbf{Relatório Final}\linebreak\linebreak
\linebreak\linebreak
\includegraphics[scale=0.1]{feup-logo.png}\linebreak\linebreak
\linebreak\linebreak
\Large{Mestrado Integrado em Engenharia Informática e Computação} \linebreak\linebreak
\Large{Programação em Lógica}\linebreak
}

\author{\textbf{Grupo Ploy_4:}\\ Gonçalo Ribeiro - 201403877 \\ Nuno Martins - 201405079 \\\linebreak\linebreak \\
 \\ Faculdade de Engenharia da Universidade do Porto \\ Rua Roberto Frias, s\/n, 4200-465 Porto, Portugal \linebreak\linebreak\linebreak
\linebreak\linebreak\vspace{1cm}}
\date{13 de Novembro de 2016}
\maketitle
\thispagestyle{empty}

%************************************************************************************************
%************************************************************************************************

\newpage

\section*{Resumo}
Para o 1º Trabalho Prático, o nosso grupo implementou o jogo de tabuleiro Ploy em Prolog - uma linguagem de programação em lógica.
O principal objectivo deste trabalho foi aplicar os conhecimentos adquiridos sobre o paradigma de programação em lógica, lecionados na unidade curricular PLOG.
O resultado final é um versão funcional do jogo com interface de texto. Foi também implementada um inteligência artificial capaz de fazer jogadas aleatórias ou gananciosas.
Como considerações finais, estamos satisfeitos com o trabalho que realizámos e concordamos que foi uma experiência enriquecedora e que de certa forma colocou à prova os nossos conhecimentos de lógica e a nossa capacidade de aprender um novo paradigma de programação num espaço de tempo relativamente pequeno.

%Resumo sucinto do trabalho com 150 a 250 palavras (problema abordado, objetivo, como foi o problema resolvido/abordado, principais resultados e conclusões).

\newpage

\tableofcontents

%************************************************************************************************
%************************************************************************************************

%*************************************************************************************************
%************************************************************************************************

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introdução}
No âmbito da unidade curricular de Programação em Lógica, foi-nos proposto para o primeiro trabalho prático a elaboração de um jogo de tabuleiro com a línguagem Prolog. O jogo foi selecionado de uma lista de jogos sedida pelos docentes. A escolha do Ploy como objecto do nosso trabalho residiu no interesse mútuo que temos por jogos da família do xadrez.
O objetivo deste trabalho foi pôr em prática os conhecimentos adquiridos sobre programação em lógica. Programação em lógica é um paradigma de programação baseado em lógica formal. Um programa escrito neste paragima é um conjunto de premissas e expressões em forma lógica, que expressam factos e regras sobre o dominio do problema. A línguagem Polog é uma das linguagens de programação lógica, desenvolvida por Alain Colmerauer - cientista de computação francês - em 1972.


%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{O Jogo Ploy}
Ploy é um jogo de tabuleiro para 2 ou 4 jogadores. Neste trabalho apenas nos focámos na versão de 2 jogadores.
Lançado em 1970 pela a empresa Minnesota Mining and Manufacturing, o jogo consiste num tabuleiro 9 por 9 onde cada jogador tem um conjunto de 15 peças.
O objetivo do jogo é capturar o Commander adversário (semelhante ao Rei no xadrez) ou então todas as peças menos o Commander. A captura de peças efectua-se da mesma maneira que no xadrez - movendo-se um peça para uma casa ocupada por uma peça adversária. Em cada turno, o jogador pode escolher uma peça para jogar. Uma jogada consiste em rodar a peça escolhida (45º para qualquer sentido) ou então mover a peça numa das direções para qual ela aponta. O número de casas é mover é determinado pelo tipo de peça.

Cada conjunto de peças contem:
\begin{table}[]
\centering
\label{Conjunto de peças de cada jogador.}
\begin{tabular}{lllll}
                   Shields(*) Probes  Lances  Commander \\
Quantidade         3          5       6       1         \\
Casas a mover      1          2       3       1         \\
Direções apontadas 1          2       3       4         \\
\end{tabular}
\caption{(*) Os Shields são as únicas peças que podem ser rodadas e movidas na mesma jogada.}
\end{table}

\begin{figure}[h]
\caption{Estado inicial do jogo.}
\centering
\includegraphics[width=0.8\textwidth]{ploy.gif}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lógica do Jogo}

Descrever o projeto e implementação da lógica do jogo em Prolog, incluindo a forma de representação do estado do tabuleiro e sua visualização, execução de movimentos, verificação do cumprimento das regras do jogo, determinação do final do jogo e cálculo das jogadas a realizar pelo computador utilizando diversos níveis de jogo. Sugere-se a estruturação desta secção da seguinte forma:

\subsection{Representação do Estado do Jogo} Pode ser idêntico ao descrito no relatório intercalar.)

\subsection{Visualização do Tabuleiro} (Pode ser idêntico ao descrito no relatório intercalar.)

\subsection{Lista de Jogadas Válidas} Obtenção de uma lista de jogadas possíveis. Exemplo: \textit{valid\_moves(+Board, -ListOfMoves)}.

\subsection{Execução de Jogadas} A realização de jogadas são feitas através dos predicados \textit{movePiece(+X,+Y,+Orientation,+Length,+Board,-NewBoard,-Consumed)} ou \textit{rotatePiece(Piece,Orientation,PieceNova)} em conjunto com \textit{setPiece(+X,+Y,+Board,-NewBoard,+Piece)}, dependendo se o utilizador deseja mover a peça ou rodá-la.
No predicado que realiza movimento da peça, X e Y representam as coordenadas da pela, Orientation a direção em que a peça se deve mover, Length a distancia que deve percorrer, e Board o estado de jogo atual.
Os retornos deste predicado são um novo estado de jogo NewBoard e o nº de direções da peça consumida(0 se nao foi consumida nenhuma).
Neste predicado, são efetuadas várias verificações se o movimento da peça é possível, nomeadamente:\\Se a Orientation está presente na peça (\textit{assertHasOrientation(Orientation,Piece)}) ;\\Se a distância é possível (\textit{assertValidLength(Length,Piece)}) ;\\Se o destino está dentro do tabuleiro (\textit{assertInsideBoundaries(Xf,Yf)});\\Se todas as casas até ao destino estão vazias, e se o destino ou está vazio ou contem um inimigo (\textit{assertNoCollision(X,Y,Orientation,Length,Board)}).\\
A rotação de uma peça é efetuada através de \textit{rotatePiece} e \textit{setPiece}, não sendo necessárias nenhumas verificações, pois a rotação de uma peça nunca pode falhar.

\subsection{Avaliação do Tabuleiro} Avaliação do estado do jogo, que permitirá comparar a aplicação das diversas jogadas disponíveis. Exemplo: \textit{value(+Board, +Player, -Value)}.

\subsection{Final do Jogo} A verificação do final do jogo é feita através do predicado \textit{assertGameEnded(+Board,-Winner)}.\\
Neste predicado, Board representa o estado de jogo atual, e Winner refere a equipa vitoriosa caso o predicado seja verdadeiro.
Por sua vez , este predicado chamará outros 2 predicados para cada equipa, \textit{assertCommanderDead(+Board,+Team)} e \textit{assertAllSmallDead(+Board,+Team)}, que testam as duas condições de terminação de jogo, que são, respetivamente, quando o Commander de uma das equipas é capturado ou quando todas as peças excepto o Commander de uma equipa são capturadas.

\subsection{Jogada do Computador} A escolha da jogada pelo bot é feita através do predicado \textit{bot\_plays\_diff(+Dif,+Board,+Team,-NewBoard)}. \\
Neste predicado, Dif representa a dificuldade do bot, Board é o estado de jogo atual, Team a equipa do bot e NewBoard o novo estado de jogo depois de efetuada a jogada. \\
Dif pode tomar 2 valores possíveis, podendo estes ser 0(bot aleatório) e 1(bot ganancioso).
O bot aleatório fará sempre jogadas completamente aleatórias,enquanto que o bot ganancioso procurará recursivamente qual a melhor jogada a fazer nesse mesmo turno, sendo o factor a maximizar a peça inimiga capturada(quantas mais direçoes tiver a peça, maior a prioridade).
Assim, uma peça com 4 direções tem prioridade sobre uma de 3, esta tem prioridade sobre uma de 2, e a de 2 tem prioridade sobre a de 1.Se não for encontrada nenhuma jogada que resulte na captura de uma peça, o bot ganancioso chama o predicado do bot aleatório, ou seja, com Dif = 0.



%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface com o Utilizador}

Descrever o módulo de interface com o utilizador em modo de texto.


%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusões}
Como considerações finais, estamos satisfeitos com o trabalho que realizámos e concordamos que foi uma experiência enriquecedora e que de certa forma colocou à prova os nossos conhecimentos de lógica e a nossa capacidade de aprender um novo paradigma de programação num espaço de tempo curto.
Não nos deparamos com nenhuma dificuldade concreta durante a implementação do jogo. No entanto, esta foi relativamente lenta e laborosa, visto que estavamos activamente a aprender Polog enquanto faziamos o projecto, o que implicou uma constante consulta de documentação e uma abordagem "trial by error" de programação.
Ambos concordamos que deviamos ter começado a elaboração do relatório mais cedo, em vez de o deixarmos para ultima prioridade. Assim teríamos mais tempo para adicionar mais conteúdo e refinar o restante. Tirando isso, sentimos que conseguimos fazer tudo ao que nos propomos no início do desenvolvimento.
Em suma, reconhecemos o potencial do Prolog como ferramenta para o ensino didatico de lógica, mas, na prespectiva de quem usa maioritariamente linguagens imperativas (C, C++, Java), é pouco funcional - não nos dá ferramentas suficientes para atacarmos diretamente um problema, é necessário criar múltiplos predicados para relizar coisas tão simples como iterar listas.

%Que conclui deste projecto? Como poderia melhorar o trabalho desenvolvido?


\clearpage
\addcontentsline{toc}{section}{Bibliografia}
\renewcommand\refname{Bibliografia}
\bibliographystyle{plain}
\bibliography{myrefs}

\newpage
\appendix
\section{Nome do Anexo}
Código Prolog implementado devidamente comentado e outros elementos úteis que não sejam essenciais ao relatório.

\end{document}
